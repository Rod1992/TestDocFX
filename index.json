{
  "api/Global.ExampleScript.html": {
    "href": "api/Global.ExampleScript.html",
    "title": "Class ExampleScript | Test DocFx Unity Documentation",
    "keywords": "Class ExampleScript Inheritance Object ExampleScript Namespace : Global Assembly : cs.temp.dll.dll Syntax public class ExampleScript : MonoBehaviour Methods Myfunction(Boolean, Boolean) Declaration public void Myfunction(bool yes, bool ofc) Parameters Type Name Description Boolean yes Boolean ofc RodisTheMC(Boolean, Boolean) Declaration public void RodisTheMC(bool yes, bool ofc) Parameters Type Name Description Boolean yes Boolean ofc"
  },
  "api/Global.html": {
    "href": "api/Global.html",
    "title": "Namespace Global | Test DocFx Unity Documentation",
    "keywords": "Namespace Global Classes ExampleScript"
  },
  "manual/Add-a-new-decor.html": {
    "href": "manual/Add-a-new-decor.html",
    "title": "Model Import | Test DocFx Unity Documentation",
    "keywords": "Model Import Import the model in the project folder Asset/Meshes/Map/[LocationName] Have a look at the other models (PortoCervo for instance) to use the same options. From the model, create a prefab with the final name. (it need to be same as the '_id' choosen for the GS Database so no spaces ,no uppercase, no special characters). Add the following components to the prefab: DecorColorization: for colors presets based on time of day DecorPlacement, adjust accordingly The global position and scaling. Used for the marina position and rotation (The decor is loaded in the marina scene after a race in this location). For the introduction camera: Setup a child with a DecorPanorama component and a CinemachineSmoothPath In the CinemachineSmoothPath, set the path points to go around the decor nicely (or ask a graphist) In doubt, check the other decor prefabs. Finally, set the assetbundle name for the prefab with the prefix \"decor_\", for instance \"decor_honolulu\" Decor images The decor requires 4 images (provided by the graphist) to be added in the asset bundle decor_imgs. A small image for the lobby. Ex: honolulu A large image for the lobby. Ex: honolulu-2 A flag image if not already present using the IOC code with the prefix \"flag-\", it need to be put in the folder \"Assets/Resources/Textures/MapFlags\" An image containing the new decor's name for sailGP boundaries Put it in project's folder: Assets/Textures/Gameplay/Boundaries_Logos In the Gameplay scene, search for raceBoundaries and add the Sprite the the logo library list You can have an overview of all the AssetBundles in Window > AssetBundleBrowser Gamesparks setup Add the entry in the database script.location : { \"_id\": \"portocervo\", //name of the assetbundle is decor_portocervo + used in the decor images \"name\": \"PortoCervo\", //name of the prefab \"country\": { // for display of flag mostly \"_id\": \"IT\", \"IOC\": \"ITA\", \"name\": \"Italy\" }, \"timezone\": 1 //used for the colorization based on time of day }"
  },
  "manual/BoatConfig.html": {
    "href": "manual/BoatConfig.html",
    "title": "Localisation | Test DocFx Unity Documentation",
    "keywords": "Localisation Client: Git: https://github.com/virtualregatta/VRI2K16 Chemin: proto/src/client/unity/Assets/Scripts/Simulation/Boat/Engine/BoatConfig.cs Serveur: Git: https://github.com/virtualregatta/VRI2k16-Photon-Server Chemin: src/server/VRI2k16.Common/Config/BoatConfig.cs Structure La configuration des bateaux sur VRI est structurée autour des différentes composantes du moteur (BoatEngine), auxquelles viennent s’ajouter d’autres informations qui ne sont pas directement liées au moteur. Les données de configuration de bateau sont donc scindées en 10 parties, dont 6 correspondent aux 6 composantes moteurs: Données générales (utilisation diverse, serveur/client) Données de contour (utilisées dans le système de collisions, serveur) Données de voiles (utilisées par le moteur, serveur/client) Données de pénalité (utilisées par le moteur, serveur/client) Données du choqué des voiles (utilisées par le moteur, serveur/client) Données de rotation (utilisées par le moteur, serveur/client) Données d’avancement (utilisées par le moteur, serveur/client) Données de dérive (utilisées par le moteur, serveur/client) Données de vol (utilisées par le client) Données d’améliorations du bateau (dépréciées, précédemment utilisées par le moteur, serveur/client) Détail de la configuration Données générales (utilisation diverse, serveur/client) [XmlElement(“general”)] public GeneralSetup General = new GeneralSetup(); Contient: [expert] EngineStepMs: Le delta temps entre deux appels du Run du moteur (par défaut 33 ms) BoatId: L’identifiant du bateau Name: Le nom du bateau HullLengthMeters: La longueur du bateau (hors-tout) HullWidthMeters: La largeur du bateau (hors membres) VisualScaling: L’échelle de présentation du bateau (par défaut 0.5, soit 50%) [expert] UnityTag: Le tag du bateau pour les assets bundles (client) [expert] UnityPrefabName: Le nom du prefab du bateau pour les assets bundles (client) [expert] SternMaxPercent: Le pourcentage de longueur pour considérer le chevauchement au niveau de la poupe du bateau [expert] MatchRaceCourseId: L’identifiant de parcours préférentiel pour les challenges de type Match. [expert] TrainingChallengeId: L’identifiant du challenge d'entraînement lié au bateau. [expert] PrivateChallengeId: L’identifiant du challenge de courses privées lié au bateau. Données de contour (utilisées dans le système de collisions, serveur) [XmlElement(“outline”)] public OutlineSetup Outline = new OutlineSetup(); Contient: PointsUpwind: Les points définissant le contour du bateau au près (ie en foc). PointsDownwind: Les points définissant le contour du bateau au portant (ie en spi). Note : la forme peut changer selon le type de voile déployée (comme par exemple avec un bout dehors amovible/rétractable). Données de voiles (utilisées par le moteur, serveur/client) [XmlElement(“sails”)] public SailsSetup Sails = new SailsSetup(); Contient: [expert] Jib: Les polaires du foc, soit un ou plusieurs tableaux (un pour chaque vitesse de vent arbitrairement définie) de 181 valeurs de vitesse (une par angle TWA, de 0 à 180 inclus). [expert] Gennaker: Les polaires du spi, soit un ou plusieurs tableaux (un pour chaque vitesse de vent arbitrairement définie) de 181 valeurs de vitesse (une par angle TWA, de 0 à 180 inclus). [expert] HasGennaker: Le flag (bool) définissant si le bateau a ou non un spi. SailsSwitchTimeS: Le temps de changement de voile. [expert] Flap: Les données de fasseyement (angles TWA seuils, au près et portant pour le spi, au près pour le foc). Notes : Si le bateau n’a pas de spi, le changement de voile ne pouvant pas se faire, les polaires Gennaker seront ignorées. Données de pénalité (utilisées par le moteur, serveur/client) [XmlElement(“penalty”)] public PenaltySetup Sails = new PenaltySetup(); Contient: SpeedRatio: Le facteur de vitesse à appliquer lors d’un pénalité. [expert] DecelerationDamping: La valeur d’amortissement pour le calcul du facteur d’influence de la pénalité, au moment de l’application de la pénalité (plus elle est grande, plus le bateau ralentit rapidement) [expert] AccelerationDamping: La valeur d’amortissement pour le calcul du facteur d’influence de la pénalité au moment de sortir de la pénalité (plus elle est grande, plus le bateau ré-accélère rapidement) DurationS: La durée de la pénalité en secondes. Données du choqué des voiles (utilisées par le moteur, serveur/client) [XmlElement(“trim”)] public TrimSetup Outline = new TrimSetup(); Contient: [expert] SpeedRatio: Le facteur de vitesse à appliquer lors du choqué des voiles (tous les bateaux sont à 0 par défaut) [expert] DecelerationDamping: La valeur d’amortissement pour le calcul du facteur d’influence du choqué des voiles, au moment de l’application du choqué des voiles (plus elle est grande, plus le bateau ralentit rapidement). [expert] AccelerationDamping: La valeur d’amortissement pour le calcul du facteur d’influence du choqué des voiles, au moment de re-border les voiles (plus elle est grande, plus le bateau ré-accélère rapidement) [expert] RatioMultiplicatorOverTwa: Un tableau de 181 valeurs (une par degré TWA entre 0 et 180 inclus) définissant la variation de la valeur maximale d’influence du choqué des voiles en fonction de l'angle au vent. Note : Ces valeurs n’ont pas vraiment vocation à changer d’un bateau à l’autre, mais sont utiles pour avoir un comportement plus crédible sur l’ensemble des bateaux. Données de rotation (utilisées par le moteur, serveur/client) [XmlElement(“rotation”)] public RotationSetup Rotation = new RotationSetup(); Contient: BaseSpeed: La vitesse de rotation cible de référence en degrés/seconde [expert] TapForcedSpeed: La vitesse de rotation forcée pour le contrôle au tap degré par degré. BaseAccelerationDamping: La valeur d’amortissement pour l’accélération (plus elle est grande, plus l’accélération est forte - pour atteindre une vitesse cible supérieure à celle de l’état de bateau précédent). BaseDecelerationDamping: La valeur d’amortissement pour la décélération (plus elle est grande, plus la décélération est forte - pour atteindre un vitesse cible inférieure à celle de l’état de bateau précédent). [expert] MinSpeedPercent: Le pourcentage de la vitesse cible de référence définissant la vitesse de rotation minimum du bateau. [expert] AdvanceSpeedRefKnots: La vitesse d’avancement référence pour mettre la vitesse de rotation à l’échelle (la vitesse d’avancement du bateau influe sur la vitesse de rotation du bateau). [expert] AccelerationDampingRatioOverTwa: Un tableau de 181 valeurs (une par degré TWA entre 0 et 180 inclus) définissant la variation de la valeur maximale d’amortissement pour l’accélération par rapport à l’angle au vent. Note: Ces valeurs peuvent être considérées comme constantes, et pour changer significativement la dynamique du bateau, mieux vaut modifier BaseAccelerationDamping. [expert] DecelerationDampingRatioOverTwa: Un tableau de 181 valeurs (une par degré TWA entre 0 et 180 inclus) définissant la variation de la valeur maximale d’amortissement pour l’accélération par rapport à l’angle au vent. Note: Ces valeurs peuvent être considérées comme constantes, et pour changer significativement la dynamique du bateau, mieux vaut modifier BaseDecelerationDamping. [expert] AutoSimulationMaxNumIterations: Le nombre maximum d’itérations pour simuler la rotation automatisée du bateau (pour l’auto TWA et l’auto tack). [expert] TwaTargetAngleDegreesStopThreshold: La différence d’angle en deçà de laquelle le bateau se cale sur l’angle cible en cas de rotation automatisée du bateau (pour l’auto TWA et l’auto tack) [expert] PanicModeMaxRotationSpeed: (client uniquement) La valeur max de vitesse de rotation en deçà de laquelle le bouton du “mode panique” peut apparaître dans l’interface du jeu en course. [expert] PanicModeHeadingDegrees: La valeur de cap sur laquelle se cale instantanément le bateau quand le “mode panique” est enclenché. Note : Cette valeur est en fait ajoutée (ou retirée, en fonction du signe du TWA courant sur [-180; 180]) à celle de l’azimut du vent (TWD) pour définir le cap de sortie. boatState.Rotation.HeadingDegrees = (boatState.Wind.TwaDegrees < 0f) ? boatConfig.Rotation.PanicModeHeadingDegrees + boatState.Wind.TwdDegrees : -boatConfig.Rotation.PanicModeHeadingDegrees + boatState.Wind.TwdDegrees; [expert] SpeedTresholdForManeuver: (pour les règles uniquement) La valeur seuil de vitesse de rotation du bateau au delà de laquelle le joueur est considéré comme en train de manoeuvrer. Données d’avancement (utilisées par le moteur, serveur/client) [XmlElement(“advance”)] public AdvanceSetup Advance = new AdvanceSetup(); Contient: BaseAccelerationDamping: La valeur d’amortissement pour l’accélération (plus elle est grande, plus l’accélération est forte - pour atteindre une vitesse cible supérieure à celle de l’état de bateau précédent). BaseDecelerationDamping: La valeur d’amortissement pour la décélération (plus elle est grande, plus la décélération est forte - pour atteindre un vitesse cible inférieure à celle de l’état de bateau précédent). AccelerationDampingRatioOverTwa: Un tableau de 181 valeurs (une par degré TWA entre 0 et 180 inclus) définissant la variation de la valeur maximale d’amortissement pour l’accélération par rapport à l’angle au vent. Note: Ces valeurs peuvent être considérées comme constantes, et pour changer significativement la dynamique du bateau, mieux vaut modifier BaseAccelerationDamping. DecelerationDampingRatioOverTwa: Un tableau de 181 valeurs (une par degré TWA entre 0 et 180 inclus) définissant la variation de la valeur maximale d’amortissement pour la décélération par rapport à l’angle au vent. Note: Ces valeurs peuvent être considérées comme constantes, et pour changer significativement la dynamique du bateau, mieux vaut modifier BaseDecelerationDamping. [expert] SpeedFactor: Un facteur de vitesse à appliquer à la vitesse d’avancement en sortie (1 par défaut). Données de dérive (utilisées par le moteur, serveur/client) [XmlElement(\"drift\")] public DriftSetup Drift = new DriftSetup(); Contient: [expert] AccelerationDamping: La valeur d’amortissement pour le calcul du facteur d’influence de la dérive au moment de sortir de dérive, c’est à dire quand on dépasse un certain seuil de vitesse d’avancement du bateau (plus cette valeur est grande, plus le bateau repart rapidement). [expert] DecelerationDamping: La valeur d’amortissement pour le calcul du facteur d’influence de la dérive au moment de dériver, c’est à dire quand on passe en dessous d’un certain seuil de vitesse d’avancement du bateau (plus cette valeur est grande, plus le bateau atteint sa vitesse de dérive cible rapidement). [expert] SpeedKnotsThreshold: Le seuil de vitesse en deçà duquel le bateau part à la dérive. MaxSpeedKnots: La valeur maximale de vitesse de dérive. [expert] WindSpeedReferenceKnots: La valeur de vitesse de vent référence pour mettre à l’échelle la vitesse de dérive (le TWS influe sur la vitesse de dérive). Données de vol (utilisées par le client) [XmlElement(\"fly\")] public FlySetup Fly = new FlySetup(); [expert] SpeedKnotsThreshold: La vitesse d’avancement seuil au delà de laquelle le bateau se met à voler (utilisée pour des bateaux tels que le Nacra 17 et le Formula 18). Note: si cette valeur est à 0, le bateau ne vole pas. [expert] HeightMeters: La hauteur à laquelle le bateau vole quand il vole. [expert] AccelerationDamping: La valeur d’amortissement pour l’accélération ET la décélération (plus elle est grande plus le bateau décolle/atterrit vite). Données d’améliorations du bateau (dépréciées, précédemment utilisées par le moteur, serveur/client) [XmlElement(\"upgrade\")] public UpgradeSetup Upgrade = new UpgradeSetup(); BoatAdvSpeedUpwindModStep : La valeur en pourcentage de vitesse au près ajoutée à chaque pas d’amélioration. BoatAdvSpeedDownwindModStep : La valeur en pourcentage de vitesse au portant ajoutée à chaque pas d’amélioration. BoatRotModStep : La valeur en pourcentage de vitesse de rotation ajoutée à chaque pas d’amélioration. BoatSailSwitchTimeModStep : La valeur de temps en secondes retirée au temps total de changement de voile du bateau à chaque pas d’amélioration. Note: si ce temps est inférieur ou égal à 0, la voile change instantanément. Notes générales Les classes de configuration du client et du serveur sont identiques. Les données d’amélioration du bateau ne sont plus utilisées car on ne peut plus améliorer ses bateaux dans le jeu. Elle pourraient être retirées. Le TWA et le cap sont exprimés en degrés dans l’intervalle [-180, 180] Le TWD est exprimé en degrés. Les vitesses (avancement, dérive, TWS) sont exprimées en noeuds. Les données flagués [expert] sont cachées par défaut dans le panneau d’administration des bateaux sur la plateforme GameSparks. Démo Lien vers la démo Aperçu du panneau d’administration des bateaux sur la plateforme GameSparks Exemple du Nacra 17:"
  },
  "manual/BoatEngine.html": {
    "href": "manual/BoatEngine.html",
    "title": "Localisation | Test DocFx Unity Documentation",
    "keywords": "Localisation Client: Git: https://github.com/virtualregatta/VRI2K16 Chemin: proto/src/client/unity/Assets/Scripts/Simulation/Boat/Engine/BoatEngine.cs Serveur: Git: https://github.com/virtualregatta/VRI2k16-Photon-Server Chemin: src/server/VRI2k16.Common/Simulation/Engine.cs Structure Le boat engine de VRI prend en entrée un delta temps entre chaque frame de calcul (float, en secondes), un boat state initial passé en référence (BoatState,modifié et tenant lieu de retour), et une configuration du bateau (BoatConfig). La fonction principale d’exécution est la suivante: public BoatState Run(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig) Les 6 composantes de la dynamique du bateau sont exécutées selon un ordre défini. Les commandes dans le Run sont les suivantes: Déployer une voile le cas échéant (spi ou foc, via action joueur). Appliquer une pénalité le cas échéant (qui influe sur la vitesse du bateau, via le calcul des règles de régate). Choquer les voiles le cas échéant (via action joueur). Calculer la vitesse de rotation du bateau (via action joueur). Calculer la vitesse d’avancement du bateau. Calculer la vitesse de dérive le cas échéant (via la configuration du bateau). Chaque exécution est également dépendante du contenu du boat state de référence (état précédent du bateau, BoatState). Le Run du bateau doit être appelé à intervalle régulier, plusieurs fois par seconde (par défaut 30 fois par seconde, soit un delta temps de 33 millisecondes, cette valeur étant configurable en modifiant le EngineStepMs dans le BoatConfig). Détail des exécutions (1.) Déployer une voile le cas échéant (spi ou foc, via action joueur). private void _HandleSailActive(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig, BoatModification boatModification) Cette fonction permet de: démarrer le décompte pour le changement de voile ( BoatConfig.Sails.RemainingSwitchTimeS ) en cas d’action joueur ( BoatState.Action.SailSwitchToGennaker ), si un changement de voile n’est pas déjà en cours. Faire le décompte (en utilisant le delta temps deltaTimeS) et exécuter le changement de voile en fin de décompte ( BoatState.Sails.IsInGennaker ). (2.) Appliquer une pénalité le cas échéant (qui influe sur la vitesse du bateau, via le calcul des règles de régate). private void _ComputePenalty(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig) Cette fonction permet de: Calculer un facteur d'influence de la pénalité sur la dynamique globale du bateau ( BoatState.Penalty.Ratio ), 0 pour une influence totale et 1 pour une influence nulle (suivant BoatState.Penalty.IsActive ). Le facteur converge vers sa valeur cible suivant les les valeurs d’amortissement passées en configuration ( BoatConfig.Penalty.AccelerationDamping , et_ BoatConfig.Penalty.DecelerationDamping_). (3.) Choquer les voiles le cas échéant (via action joueur). private void _ComputeTrim(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig) Cette fonction permet de: Calculer un facteur d’influence du choqué des voiles sur la dynamique globale du bateau ( BoatState.Trim.Ratio ), une valeur min >= 0 pour une influence totale et 1 pour une influence nulle (suivant BoatState.Action.Trim ). Le facteur converge vers sa valeur cible suivant les valeurs d’amortissement passées en configuration ( BoatConfig.Trim.AccelerationDamping , et BoatConfig.Trim.RatioMutiplicatorOverTwa ). Note: la valeur du facteur d’influence totale suit une courbe fonction du TWA, pour un retour entre 0 et 1. Cette courbe est pour l’heure commune à tous les bateaux et n’a pas vocation à être modifiée. (4.) Calculer la vitesse de rotation du bateau (via action joueur). private void _ComputeRotation(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig, BoatModification boatModification) Cette fonction permet de: Gérer le “mode panique” (rotation forcée appliquée instantanément, la valeur est définie dans BoatConfig.Rotation.PanicModeHeadingDegrees ) Note: le “mode panique” est accessible au joueur quand il est bout au vent depuis un certain temps et que la vitesse angulaire de son bateau est faible. Calculer la vitesse de rotation cible en fonction des inputs et de l’état précédent du bateau ( BoatState.Action.XAxis et BoatState.Action.TapCheck ). Note 1: Le tap check est utilisé durant un certain laps de temps (défini et commandé par le client) pour permettre au bateau de virer degré par degré (TWA). La vitesse de rotation cible est fixée à une valeur fixe assez faible définie en configuration ( BoatConfig.Rotation.TapForcedSpeed ). Note 2: La vitesse d’avancement du bateau a une influence sur la vitesse de rotation du bateau, se basant sur une vitesse d’avancement référence définie en configuration ( BoatConfig.Rotation.AdvanceSpeedRefKnots ). Faire converger le bateau vers un angle cible (TWA ou cap, BoatState.Action.AngleTarget ) le cas échéant (auto TWA activé ou auto tack enclenché). Calculer la vitesse de rotation du bateau ( BoatState.Rotation.Speed ) et son cap ( BoatState.Rotation.HeadingDegrees ). (5.) Calculer la vitesse d’avancement du bateau. private void _ComputeAdvance(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig, BoatModification boatModification) Cette fonction permet de: Calculer le TWA. Calculer la vitesse cible (dépendante du facteur d’influence sur une éventuelle pénalité et/ou du facteur d’influence sur le choqué des voiles). Note: la vitesse cible est définie par la polaire du bateau présente en configuration (vitesse en fonction du TWA et de la voile, BoatConfig.Sails.Gennaker.Vpps et BoatConfig.Sails.Jib.Vpps ). Faire converger la vitesse du bateau vers la vitesse cible (l’accélération et la décélération étant définie par un amortissement fonction du TWA). Note: cette fonction est présente pour affiner les comportement général du bateau, il n’est pas forcément nécessaire de la modifier pour régler l’accélération/la décélération du bateau, mieux vaut modifier les valeurs d’amortissement ( BoatConfig.Advance.BaseAccelerationDamping et BoatConfig.Advance.BaseDecelerationDamping ). Calculer la position du bateau. Note: l’avancement est calculé sur l’axe du bateau défini par son cap. (6.) Calculer la vitesse de dérive le cas échéant (via la configuration du bateau). private void _ComputeDrift(float deltaTimeS, ref BoatState boatState, BoatConfig boatConfig) Cette fonction permet de: Calculer le facteur d’influence de dérive, 0 pour une influence nulle et 1 pour une influence totale. Le facteur converge vers sa valeur cible suivant les les valeurs d’amortissement passées en configuration ( BoatConfig.Drift.AccelerationDamping , et BoatConfig.Drift.DecelerationDamping ). Note: la dérive se déclenche quand la vitesse d’avancement du bateau passe en dessous d’un seuil de vitesse défini en configuration ( BoatConfig.Drift.SpeedKnotsThreshold ). Calculer la vitesse de dérive ( BoatConfig.Drift.SpeedKnots ) en fonction de la force du vent ( BoatState.Wind.TwsKnots ) et d’une vitesse de vent référence arbitraire définie en configuration ( BoatConfig.Drift.WindSpeedReferenceKnots ). Calculer la position du bateau (potentiellement modifiée par la dérive) Note: l’avancement est calculé sur l’axe du vent (TWD, BoatState.Wind.Degrees ). Notes générales Les classes d’engine du client et du serveur sont identiques. Certaines composantes utilisent les modifications de bateau ( BoatState.BoatModification ) mais celles-ci n’ont aucun impact étant donné que les améliorations de bateaux ne sont plus disponibles dans le jeu. Elle pourraient être retirées. Le TWA et le cap sont exprimés en degrés dans l’intervalle [-180, 180] Le TWD est exprimé en degrés. Les vitesses (avancement, dérive, TWS) sont exprimées en noeuds. Démo Lien vers la démo"
  },
  "manual/Build-and-deploy-AssetBundles.html": {
    "href": "manual/Build-and-deploy-AssetBundles.html",
    "title": "Build | Test DocFx Unity Documentation",
    "keywords": "Les AssetBundles sont utilisés principalement pour les bateaux et les décors de VRI afin de pouvoir les sortir de la build principale et de les mettre à jour sans avoir à créer une nouvelle version de l'app. Build Dans un premier temps, pour tester les asset bundles dans l'éditeur, il faut utiliser le mode Simulation qui ne nécessite pas de les builder. Une fois validé, il faut les builder avec le menu Asset/AssetBundles/Build AssetBundles pour chaque plate-forme (au moins iOS, Android et WebGL) Deploy Il faut dans un premier temps déposer les assetBundles sur la machine dev.virtualregatta.com dans le répertoire /data/vri2k17/AssetBundles via un logiciel de ftp (FileZilla, WinSCP). Ensuite, se connecter en ssh sur ubuntu@dev.virtualregatta.com:22 et se déplacer dans le dossier /data/vri2k17 . Le déploiement se fait sur Amazon S3, il faut donc utiliser le script bash s3_deploy.sh : ./s3_deploy.sh -ab [-p] [-v \"versionName\"] -ab pour préciser que l'on souhaite déployer les assetBundles -p permet de préciser si l'on veut déployer sur l'environnement de production -v permet de donner un nom spécifique à la version récupérée. Par défaut il s'agit de la date du jour au format YYYYMMDD. Il est préférable de laisser le nom par défaut, mais si c'est nécessaire, préférez un nom au même format avec un suffixe, exemple: 20190802-montest. Pour pouvoir utiliser ces assets avec l'application courante, direction l' admin de Gamesparks . Ensuite dans Manage>Settings: Attention de bien choisir Preview(dev) ou Live(prod). Les AssetBundles sont renseignés en bas avec un détail par plateforme et par version de l'app."
  },
  "manual/Build-and-deploy-for-Android.html": {
    "href": "manual/Build-and-deploy-for-Android.html",
    "title": "Avant de builder | Test DocFx Unity Documentation",
    "keywords": "Avant de builder A partir du 01/08/2019, les applications doivent proposer le format 64 bits. A vérifier dans les Player settings: Build Pour les versions, de dev et de préprod, il est possible de builder via Unity Cloud Build Dans la configuration, la différence entre une build dev et prod se situe au niveau des define symbols: FORCE_PRODUCTION pour la production Vide pour le dev Pour builder en local, il faut utiliser dans les publishing settings les infos contenues dans VRI-sign Attention: Ne jamais pusher les project settings avec le define symbol FORCE_PRODUCTION . Version de production pour Play Store Pour la version de production destinée au Play Store, il faut dorénavant utiliser les Android App bundles pour limiter le poids de l'app suite au passge au 64 bits. Ce n'est pas encore supporté par UCB, ça doit donc être fait en local en vérifiant de bien être en configuration prod (FORCE_PRODUCTION): Soumission sur le Google Play Store Direction la Google Play Console . Une fois dans l'app et le menu Gestion de la publication > Versions de l'application, il est possible de créer/modifier la nouvelle version. Il faut que le build number soit incrémenté si un nouveau package est déposé. Sinon, il est possible de supprimer le doublon dans la bibliothèque d'artefacts. Ne pas oublier de proposer des traductions pour le changelog. Une fois la version enregistrée et verifiée, le deploiement se fait en quelques heures. Attention à bien déployer sur 100% des devices."
  },
  "manual/Build-and-deploy-for-iOS.html": {
    "href": "manual/Build-and-deploy-for-iOS.html",
    "title": "1. Build | Test DocFx Unity Documentation",
    "keywords": "1. Build Unity Depuis la machine de build: Pull de la branche de la version concernée via Github Desktop, SourceTree ou autre S’assurer que les numéros de build et de version sont correctement incrémentés: le numéro de version doit être > au dernier uploadé sur l’App store Connect S’assurer que vous buildez bien depuis une version PRO d’Unity et que le splash screen est bien configuré dans les player settings. Vérifier que l’on est en production en lançant le jeu depuis Unity Si ce n’est pas le cas, ajouter FORCE_PRODUCTION aux Scripting Define Symbols (Player Settings). Peut être ajouté via Utils > Switch Mode > Prod. Vérifier à nouveau en lançant le jeu Builder depuis Unity. XCode Ouvrir %build_folder%/Unity-iPhone.xcworkspace Valider/corriger les project settings tel que le propose Xcode dans le panneau accessible en cliquant l’icône Warning (par défaut dans la barre en haut à gauche de la fenêtre): Pods project : Validate Project Settings / Update to recommended settings Unity-iPhone project : Validate Project Settings / Update to recommended settings Sur le projet (root dans l’explorateur de projet et target Unity_iPhone), se rendre dans General>Identity vérifier le numéro de version et de build. Dans Capabilities, activer Background Modes (dans lequel Remote notification doit être coché), Push Notifications, In-App Purchase et Associated Domains (avec l'entrée \"applinks:*.virtualregatta.com\") : Vérifier dans Info que les deux champs concernant la Privacy sont renseignés tels qu’ajoutés précédemment dans le fichier Info.plist. Builder et archiver à l’aide du menu Product>Archive. Une fois l’archivage terminé, l’Organizer devrait s’ouvrir avec l’archive nouvellement créée sélectionnée. Si ce n’est pas le cas, l’Organizer s’ouvre depuis le menu Window>Organizer Pour uploader vers l’App Store depuis l’Organizer, cliquer sur “ Distribute App ” à droite et suivre la procédure en laissant tout par défaut et en auto-signant de préférence. Patienter Garder les différentes options telles quelles > Next Upload 2. Publication App Store Testflight Sur l’ App Store connect , aller dans Mes Apps > [App] > Testflight Constater que la version est en cours de vérification. Une fois que c’est terminé, un warning “Attestations manquantes” s’affiche: Cliquer sur le signe warning, puis soumettre les attestations pour l’exportation Répondre non puis commencer les tests internes Valider la version sur l’iPad Création de la version Dans l'AppStore: (+) VERSION OU PLATE-FORME Remplir le champ “Nouveautés de cette version” dans toutes les langues. Vérifier les visuels et en ajouter/supprimer si nécessaire. Dans build, rajouter la build souhaitée. Faire attention au mode de publication: auto ou manuel Valider et répondre Non sur l’identifiant publicitaire: Envoyer Si publication manuelle, attente du mail de confirmation d’Apple Enjoy!"
  },
  "manual/Build-and-deploy-for-WebGL.html": {
    "href": "manual/Build-and-deploy-for-WebGL.html",
    "title": "Build | Test DocFx Unity Documentation",
    "keywords": "Build L'integralité des builds WebGL peuvent se faire sur Unity Cloud Build Les points à vérifier dans la configuration des builds concernent la branche git utilisée et la version de Unity. Deploy Le déploiement s'effectue via un script sur une machine de dev. Il faut se connecter en ssh sur ubuntu@dev.virtualregatta.com:22. Une fois connecté, aller dans le répertoire /data/vri2k17 . Le script actuel est deploy.sh et s'utilise comme suit: ./deploy_wp.sh [-p] [-v \"versionName\"] -p permet de preciser si l'on veut déployer sur l'environnement de production -v permet de donner un nom spécifique à la version récuperée. Par défaut il s'agit de la date au format YYYMMDD suivi numéro de build UCB séparé par un tiret (signe moins). Il est préférable de ne pas spécifier de nom de version, mais si jamais, essayer de respecter le même format en la suffixant, par exemple: 20190802-425-montest. Le script récupere ensuite la dernière build UCB prod ou dev selon le param p et l'upload sur la machine concernée. A cet instant la build est visible sur l'url de preprod: https://www[-dev].virtualregatta.com/fr/inshore-jeu/[?versionRelease=[versionName]] Comme par exemple: Pour dev: https://www-dev.virtualregatta.com/fr/inshore-jeu/?versionRelease=20190612-184 Pour la preprod: https://www.virtualregatta.com/fr/inshore-jeu/?versionRelease=20190612-184 Pour la prod: https://www.virtualregatta.com/fr/inshore-jeu/ Une fois validée, pour que l'accès soit possible pour tous il faut mettre à jour la configuration du portail: https://www.virtualregatta.com/wp-login.php (ou https://www-dev.virtualregatta.com/wp-login.php pour dev) Une fois identifié, modifier la \"Version de la release WebGL de VRI\" en conséquence. Et puisque la version WebGL sera toujours live avant celles mobiles, penser à informer (via slack ou autre) le reste de la team (comm. notamment) dés que ce déploiement a eu lieu."
  },
  "manual/Creation-Arena.html": {
    "href": "manual/Creation-Arena.html",
    "title": "Gamesparks | Test DocFx Unity Documentation",
    "keywords": "Gamesparks Dans l'administration des challenges, la création d'un challenge arena se fait comme suit: Le type doit être VR Challenge Ne pas oublier de cocher enabled Cocher Private/password et rentrer un mot de passe Cocher Arena et entrer l'id du ou des organisateurs Mettre à jour les dates de visibilité et d'activité Le reste est classique Pour les arenas, il y a déjà des joueurs prédéfinis (Boat1 à BoatN) qu'il faut logger sur chaque device présent lors de l’arena. Bon réflexe : tester dans les conditions les plus proches de l’événement une journée ou deux à l'avance. A date du 17/06/2019, au dernier essai en arena, le Wifi sécurisé ne fonctionnait pas (incompatibilité Photon). A revérifier après la migration vers la nouvelle solution."
  },
  "manual/Home.html": {
    "href": "manual/Home.html",
    "title": "Build and deploy | Test DocFx Unity Documentation",
    "keywords": "Build and deploy The project is currently running on Unity 2018.4.22f1 Build and deploy for iOS Build and deploy for Android Build and deploy for WebGL Build and deploy AssetBundles Technical documentation Boat Engine Boat Config Wind Generator Import a new Boat Add a new decor Race Editor Other Création Arena Plugin List"
  },
  "manual/Import-a-new-Boat.html": {
    "href": "manual/Import-a-new-Boat.html",
    "title": "Gamesparks | Test DocFx Unity Documentation",
    "keywords": "Gamesparks Dans l'administration des challenges, la création d'un challenge arena se fait comme suit: Le type doit être VR Challenge Ne pas oublier de cocher enabled Cocher Private/password et rentrer un mot de passe Cocher Arena et entrer l'id du ou des organisateurs Mettre à jour les dates de visibilité et d'activité Le reste est classique Pour les arenas, il y a déjà des joueurs prédéfinis (Boat1 à BoatN) qu'il faut logger sur chaque device présent lors de l’arena. Bon réflexe : tester dans les conditions les plus proches de l’événement une journée ou deux à l'avance. A date du 17/06/2019, au dernier essai en arena, le Wifi sécurisé ne fonctionnait pas (incompatibilité Photon). A revérifier après la migration vers la nouvelle solution."
  },
  "manual/Plugin-List.html": {
    "href": "manual/Plugin-List.html",
    "title": "Main plugins | Test DocFx Unity Documentation",
    "keywords": "Main plugins Gamesparks API for backend services Current version: 5.6.5.214 Official website: https://www.gamesparks.com/ Gamesparks RealTime used for global chat Photon Pun2 API for realtime services Current version: 2.13 Official website: https://www.photonengine.com/pun Asset Store page: https://assetstore.unity.com/packages/tools/network/pun-2-free-119922 Firebase API for Google Firebase services such as push notifications, deep links... Current version: FirebaseMessaging + FirebaseDynamicLinks 6.0.0 Official website: https://firebase.google.com Deep links package is installed (FirebaseDynamicLinks): https://firebase.google.com/docs/unity/setup Other packages could bring analytics, crash reporting... Reporter (Unity-Logs-Viewer) Plugin to display logs and stats in built apps Secondary plugins Cinemachine Unity package to handle cameras: used ingame Current version: 2.2.9 Official website: https://unity.com/fr/unity/features/editor/art-and-design/cinemachine Play Services Resolver Plugin to solve conflicts in Android packages"
  },
  "manual/Race-Editor.html": {
    "href": "manual/Race-Editor.html",
    "title": "Overview | Test DocFx Unity Documentation",
    "keywords": "Overview The RaceEditor is a tool designed to easily create race tracks and export it to the production environment. It is supposed to be used on the Gamesparks preview environment either on a WebGL or a Standalone build. Race configuration Once a race track is configurated in the editor. The export generates a json readable for Photon and the Unity client. Actually the json is translated to XML on the Photon side then sent to the clients with the rest of the config (boat, challenge...). The structure of this (historical) XML file is identical (cf CourseConfig.cs in Photon code). Example: BANANE COURTE 2T 946m (J70 - STAR) { \"_id\": 12, \"description\": \"BANANE COURTE 2T 946m (J70 - STAR)\", \"size\": 560, \"picture\": \"/race_course/Banan-2-tour.png\", \"boatLengthToStartLineLengthCoefficient\": 3.2, \"beaconPositionRandomnessRadiusMeters\": 4, \"beacon\": [ { \"id\": 1, \"position\": { \"x\": 210, \"y\": 430 }, \"type\": \"start\", \"radius\": 1 }, { \"id\": 2, \"position\": { \"x\": 290, \"y\": 440 }, \"type\": \"start\", \"isComity\": true, \"outline\": [ { \"x\": 0, \"y\": -5.97 }, { \"x\": 1.23, \"y\": -4.34 }, { \"x\": 1.85, \"y\": -2.32 }, { \"x\": 1.85, \"y\": 6.38 }, { \"x\": -1.85, \"y\": 6.38 }, { \"x\": -1.85, \"y\": -2.32 }, { \"x\": -1.23, \"y\": -4.34 } ] }, { \"id\": 3, \"position\": { \"x\": 290, \"y\": 140 }, \"radius\": 1 }, { \"id\": 4, \"position\": { \"x\": 255, \"y\": 124 }, \"radius\": 1 }, { \"id\": 5, \"position\": { \"x\": 250, \"y\": 280 }, \"radius\": 1 }, { \"id\": 6, \"position\": { \"x\": 275, \"y\": 280 }, \"radius\": 1 } ], \"mark\": [ { \"id\": 1, \"name\": \"start1\", \"beacon\": 1, \"leave\": \"port\" }, { \"id\": 2, \"name\": \"start2\", \"beacon\": 2, \"leave\": \"stbd\" }, { \"id\": 3, \"name\": \"inter\", \"beacon\": 3, \"leave\": \"port\" }, { \"id\": 4, \"name\": \"dogleg\", \"beacon\": 4, \"leave\": \"port\" }, { \"id\": 5, \"name\": \"door1\", \"beacon\": 5, \"leave\": \"stbd\" }, { \"id\": 6, \"name\": \"door2\", \"beacon\": 6, \"leave\": \"port\" }, { \"id\": 7, \"name\": \"end1\", \"beacon\": 1, \"leave\": \"stbd\" }, { \"id\": 8, \"name\": \"end2\", \"beacon\": 2, \"leave\": \"port\" } ], \"leg\": [ { \"order\": 1, \"startmark\": [ 1, 2 ], \"endmark\": [ 3 ] }, { \"order\": 2, \"startmark\": [ 3 ], \"endmark\": [ 4 ] }, { \"order\": 3, \"startmark\": [ 4 ], \"endmark\": [ 5, 6 ] }, { \"order\": 4, \"startmark\": [ 5, 6 ], \"endmark\": [ 3 ] }, { \"order\": 5, \"startmark\": [ 3 ], \"endmark\": [ 4 ] }, { \"order\": 6, \"startmark\": [ 4 ], \"endmark\": [ 7, 8 ] } ] } Main Parameters: Size : Size in meters of one side of the race limits (being a square) boatLengthToStartLineLengthCoefficient : Ratio to control the width of the start line based on the length of the boat. beaconPositionRandomnessRadiusMeters : The beacons are positioned in a slightly random position based on this radius. beacon are all the individual buoys or comity boat id : Identifier position : position on the 2D plane (so x and z in unity) type : (optional) can be start if part startline isComity : (optional) is the beacon a comity boat oultine : (optional) in case of a comity boat, the collider outline is defined here radius : (optional) in case of a buoy, the circular collider is defined with this radius mark are defining all the elements of the gates in the race id : Identifier name : a name to easily understand which gate beacon : the beacon it uses leave : by which side the boat should go around. (port or starboad) leg defines the whole race connecting the marks together order : order in the race track startmark : array whith the mark(s) at the start of this leg endmark : array whith the mark(s) at the end of this leg"
  },
  "manual/Wind-generator.html": {
    "href": "manual/Wind-generator.html",
    "title": "Description / commentaires des variables utilisées par le générateur de vent | Test DocFx Unity Documentation",
    "keywords": "Description / commentaires des variables utilisées par le générateur de vent Note: je ne sais pas ce qui est implémenté exactement dans le code. Je commente les variables telles que je les avais conçues. Comme décrit par ailleurs, le principe général est de fonctionner par des superpositions de signaux sinusoïdaux qui modifient un vent moyen général sur le plan d’eau. Il y a un vent moyen de base (force et direction) sur lequel est aligné le parcours, ce vent moyen peut osciller ou non et est identique sur tout le plan d’eau. Par dessus se placent des sources spatiales de vent (des superpositions de sinusoïdes également) qui modifient localement le vent moyen. D'une manière générale, on balance de l’aléatoire sur l’ensemble de ce modèle, donc lorsqu'on teste, il ne faut pas se contenter d’un seul essai pour voir le résultat. Setup général Au niveau de l’admin des challenges: Direction / Speed : valeur du vent initial, avant application du modèle et des corrections. Ca correspondrait au vent que nous donnerait la NOAA ou darksky à l’endroit où se trouve le plan d’eau. Variability : C'est un pourcentage pour donner un peu d’aléatoire à cette valeur initiale. Modèle d'oscillations twd_offset : offset général du vent moyen en direction. Par exemple si on veut un vent toujours à gauche, on mettra une valeur négative (en degrés). Pas forcément nécessaire, car très prévisible du coup. mean_wind_osci : true/false. Décide si on applique ou non des oscillations sur le vent de base. wind_amplitude_vs_tws : important! Donne l’ordre de grandeur des variations de vent en force (dTws, en noeuds, échelle de gauche) et en direction (dTwd en degrés, échelle de droite) en fonction de la force du vent. L’idée est que dans le petit temps, le vent peut changer beaucoup en direction, mais moins en force. Alors que dans la brise, il change peu en direction mais plus en force. source : [ -750, -500, -250, 0, 250, 500, 750] position en latéral des sources de vent par rapport au milieu du plan d’eau. Ici 7 sources espacées de 250 m chacune. Le vent est interpolé linéairement entre deux sources. sinusoid mean / local : description de chaque série de sinusoïdes. Mean **concerne la variation du vent principal (le vent de base, qui va osciller si le **mean_wind_osci est true). Et local concerne les sources locales / spatiales de vent. Chaque bloc est un tableau de sinusoïdes, qui sont combinées entre elles pour calculer le vent final. En ce moment, il y a 4 sinusoïdes qui sont combinées entre elle pour calculer le vent final. Chaque sinusoïde est décrite par une période, une amplitude et une longueur d’onde (pour défiler sur le plan d’eau). Les coefficients servent à calculer (aléatoirement) ces valeurs pour chaque sinusoïde. periodMin / periodMax : le range de la période en minute de la sinusoïde. Une chiffre aléatoire est pris dans ce range. twsCorr : amplitude de la sinusoïde. C’est un pourcentage de l’amplitude max calculée en fonction du TWS moyen (donné par le tableau wind_amplitude_vs_tws ). Par exemple si le vent moyen est de 15 nds et twsCorr est 0.36 pour une des sinusoides, l’amplitude de cette sinusoïde est de 0.36 x 6 = 2.16 kts (le 6 étant interpolé du tableau wind_amplitude_vs_tws ) twdCorr : idem mais sur la direction. Pourcentage de la valeur de base de variation de direction donnée par le tableau wind_amplitude_vs_tws. wlCorr : correction sur la longueur d’onde. Le vent se déroule sur le plan d’eau comme un tapis roulant (qui va à la vitesse du vent). Ce facteur permet de mettre un peu d’aléatoire sur la vitesse de défilement du vent sur le plan d’eau. Plus c’est grand plus ça sera aléatoire. En pratique, cette valeur ne sert pas à grand chose. Donc si on regarde le réglage actuel, les périodes les plus longues sont pour les amplitudes les plus grandes (pour les “grandes” bascules”) et les petites oscillations apparaissent à plus haute fréquence. Il faut faire attention que la période soit cohérente avec la durée de la régate. Autre : tws_ratio: 1 twd_ratio: 1 period_ratio: 1 Je ne sais pas si ces variables sont utilisées dans le code. En tous cas leur but est de multiplier globalement les variations de vent en force, direction et les périodes de sinusoïdes par un même ratio global. Si les autres variables sont bien réglées, ces trois variables n’ont pas forcément à être utilisées. Tuning Pour ajuster le modèle: La force de vent globale se fait au niveau de l’admin des challenges (facilement reliable à une valeur retournée par DarkSky ou NOAA par exemple). La direction globale n’influera qu’uniquement sur l’orientation du vent sur le plan d’eau (car le parcours s’aligne avec cette direction). Mais cette variable a du sens maintenant qu’il y a plusieurs plans d’eau. Les variations globales en fonction du vent (plus de variations en force et/ou en direction de maniere générale) se feront le plus simplement en touchant les courbes wind_amplitude_vs_tws Pour le fine tuning d’oscillations locales, il faudra le faire sinusoide par sinusoide en changeant les ranges des périodes et les variations d’amplitudes correspondantes ( periodMin , periodMax , twsCorr , twdCorr )"
  }
}